#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
TAM PIPELINE: REINVENT ile cep modeline uygun molekÃ¼l tasarÄ±mÄ± + Lipinski kurallarÄ± + ADMET skorlarÄ± + Docking
Yazar: Duygu Ä°rem Ã–zger
AÃ§Ä±klama:
 - KullanÄ±cÄ± tarafÄ±ndan verilen cep PDB'den merkez ve boyut hesaplanÄ±r
 - REINVENT pretrained modeliyle ligand Ã¼retimi yapÄ±lÄ±r
 - Lipinski kurallarÄ±na gÃ¶re filtreleme
 - ADMET skoru hesaplama
 - Docking (AutoDock Vina)
 - QED + ADMET + Docking skorlamasÄ±
 - En iyi 2 ligand seÃ§ilir, SDF + PNG olarak kaydedilir
"""
import os
import subprocess
import numpy as np
from rdkit import Chem
from rdkit.Chem import AllChem, Descriptors, QED, Draw, rdMolDescriptors, rdmolfiles
from multiprocessing import Pool
from reinvent import load_model
from reinvent.models.scoring import ScoringFunctionFactory
import deepchem as dc

# =====================
# 0. KullanÄ±cÄ± AyarlarÄ±
# =====================
PDB_FILE = "my_pocket.pdb"
VINA_PATH = "/usr/local/bin/vina"
OUT_DIR = "top2_results"
MODEL_PATH = "reinvent_model.pt"
NUM_LIGANDS = 200
N_CPU = 4

os.makedirs(OUT_DIR, exist_ok=True)

# =====================
# 1. Pocket Analizi
# =====================
def analyze_pocket(pdb_file):
    mol = rdmolfiles.MolFromPDBFile(pdb_file, removeHs=False)
    if mol is None:
        raise ValueError(f" Pocket dosyasÄ± okunamadÄ±: {pdb_file}")
    conf = mol.GetConformer()
    coords = np.array([list(conf.GetAtomPosition(i)) for i in range(mol.GetNumAtoms())])
    center = np.mean(coords, axis=0)
    size = np.std(coords, axis=0)
    print(f"ðŸ“¦ Pocket center = {center}, size = {size*2}")
    return {'mol': mol, 'center': center, 'size': size}

# =====================
# 2. Ligand Ãœretimi (REINVENT)
# =====================
def generate_ligands_reinvent(num_ligands):
    print(" REINVENT modeli yÃ¼kleniyor...")
    model = load_model(MODEL_PATH)
    scoring_function = ScoringFunctionFactory().from_config({"name": "QEDScore"})
    
    ligands = []
    for i in range(num_ligands):
        smi = model.sample(scoring_function=scoring_function)
        mol = Chem.MolFromSmiles(smi)
        if mol is None:
            continue
        mol = Chem.AddHs(mol)
        AllChem.EmbedMolecule(mol, randomSeed=i)
        AllChem.MMFFOptimizeMolecule(mol)
        ligands.append({'smiles': smi, 'mol': mol})
    print(f" {len(ligands)} ligand Ã¼retildi.")
    return ligands

# =====================
# 3. Lipinski Filtresi
# =====================
def lipinski_violations(mol):
    mw = Descriptors.MolWt(mol)
    logp = Descriptors.MolLogP(mol)
    hbd = rdMolDescriptors.CalcNumHBD(mol)
    hba = rdMolDescriptors.CalcNumHBA(mol)
    v = 0
    if mw > 500: v += 1
    if logp > 5: v += 1
    if hbd > 5: v += 1
    if hba > 10: v += 1
    return v

# =====================
# 4. GeliÅŸtirilmiÅŸ ADMET Hesaplama
# =====================
def calc_admet_score(mol):
    """DeepChem tabanlÄ± 5 parametreli ADMET tahmini."""
    smi = Chem.MolToSmiles(mol)
    featurizer = dc.feat.MolGraphConvFeaturizer()
    mol_feat = featurizer.featurize([smi])
    
    # HazÄ±r modeller (DeepChem)
    model_names = {
        "caco2": dc.models.GraphConvModel(1, model_dir=dc.utils.get_data_dir() + "/admet/caco2"),
        "pgp": dc.models.GraphConvModel(1, model_dir=dc.utils.get_data_dir() + "/admet/pgp"),
        "cyp3a4": dc.models.GraphConvModel(1, model_dir=dc.utils.get_data_dir() + "/admet/cyp3a4"),
        "herg": dc.models.GraphConvModel(1, model_dir=dc.utils.get_data_dir() + "/admet/herg"),
        "hepatotox": dc.models.GraphConvModel(1, model_dir=dc.utils.get_data_dir() + "/admet/hepatotox")
    }

    preds = {}
    for name, model in model_names.items():
        try:
            preds[name] = float(model.predict(mol_feat)[0][0])
        except:
            preds[name] = 0.5  # belirsizse nÃ¶tr skor

    # Normalize edilmiÅŸ genel skor (1 = ideal)
    absorption = preds["caco2"]
    distribution = 1 - preds["pgp"]
    metabolism = 1 - preds["cyp3a4"]
    toxicity = (1 - preds["herg"]) * (1 - preds["hepatotox"])

    admet_score = (0.3*absorption + 0.2*distribution + 0.2*metabolism + 0.3*toxicity)
    return max(0.0, min(1.0, admet_score))

# =====================
# 5. Docking (AutoDock Vina)
# =====================
def prepare_ligand_for_vina(mol, name_prefix):
    pdbqt_file = os.path.join(OUT_DIR, f"{name_prefix}.pdbqt")
    mol_file = os.path.join(OUT_DIR, f"{name_prefix}.mol2")
    Chem.MolToMol2File(mol, mol_file)
    cmd = f"obabel {mol_file} -O {pdbqt_file} -xp"
    subprocess.run(cmd, shell=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
    return pdbqt_file

def dock_ligand(args):
    i, ligand, pocket = args
    name_prefix = f"lig_{i}"
    pdbqt_file = prepare_ligand_for_vina(ligand['mol'], name_prefix)
    out_log = os.path.join(OUT_DIR, f"{name_prefix}_vina_out.txt")
    out_pdbqt = os.path.join(OUT_DIR, f"{name_prefix}_vina_out.pdbqt")

    x, y, z = pocket['center']
    size_x, size_y, size_z = pocket['size'] * 2

    cmd = (
        f"{VINA_PATH} --receptor {PDB_FILE} --ligand {pdbqt_file} "
        f"--center_x {x:.3f} --center_y {y:.3f} --center_z {z:.3f} "
        f"--size_x {size_x:.3f} --size_y {size_y:.3f} --size_z {size_z:.3f} "
        f"--out {out_pdbqt} --log {out_log}"
    )
    subprocess.run(cmd, shell=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)

    score = 999.0
    with open(out_log, "r") as f:
        for line in f:
            if line.strip().startswith("REMARK VINA RESULT:"):
                try:
                    score = float(line.strip().split()[3])
                    break
                except:
                    pass
    return (i, score)

# =====================
# 6. Ana AkÄ±ÅŸ
# =====================
def main():
    print(" Pipeline baÅŸlatÄ±lÄ±yor...")
    pocket = analyze_pocket(PDB_FILE)

    ligands = generate_ligands_reinvent(NUM_LIGANDS)
    ligands = [l for l in ligands if lipinski_violations(l['mol']) <= 1]
    print(f" {len(ligands)} ligand Lipinski filtresinden geÃ§ti.")

    # --- ADMET hesaplama
    print("âš—ï¸ ADMET analizleri baÅŸlatÄ±lÄ±yor...")
    for l in ligands:
        l['qed'] = QED.qed(l['mol'])
        l['admet'] = calc_admet_score(l['mol'])

    # --- Docking
    print("âš™ï¸ Docking baÅŸlatÄ±lÄ±yor (paralel)...")
    with Pool(N_CPU) as pool:
        results = pool.map(dock_ligand, [(i, l, pocket) for i, l in enumerate(ligands)])
    for i, score in results:
        ligands[i]['dock_score'] = score

    # --- Skorlama
    for l in ligands:
        l['total'] = (l['qed']*0.2 + l['admet']*0.4) - (l['dock_score']/20.0)

    top2 = sorted(ligands, key=lambda x: x['total'], reverse=True)[:2]

    sdf_file = os.path.join(OUT_DIR, "top2.sdf")
    writer = Chem.SDWriter(sdf_file)
    for l in top2:
        writer.write(l['mol'])
    writer.close()

    img = Draw.MolsToGridImage(
        [l['mol'] for l in top2],
        molsPerRow=2,
        subImgSize=(400, 400),
        legends=[f"Dock={l['dock_score']:.2f}\nQED={l['qed']:.2f}\nADMET={l['admet']:.2f}" for l in top2]
    )
    img.save(os.path.join(OUT_DIR, "top2_ligands.png"))

    print(" En iyi 2 ligand:")
    for i, l in enumerate(top2, 1):
        print(f"{i}. {l['smiles']} | Dock={l['dock_score']:.2f} | QED={l['qed']:.2f} | ADMET={l['admet']:.2f}")
    print("ðŸ“ SonuÃ§ klasÃ¶rÃ¼:", OUT_DIR)

# =====================
if __name__ == "__main__":
    main()
