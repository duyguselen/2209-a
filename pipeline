#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
TAM PIPELINE: REINVENT ile cep modeline uygun molekÃ¼l tasarÄ±mÄ± + Lipinski kurallarÄ± + ADMET skorlarÄ± + Docking
Yazar: Duygu Ä°rem Ã–zger (dÃ¼zeltilmiÅŸ ve geliÅŸtirici notlarÄ±yla zenginleÅŸtirilmiÅŸ versiyon)
AÃ§Ä±klama:
 - KullanÄ±cÄ± tarafÄ±ndan verilen cep PDB'den merkez ve boyut hesaplanÄ±r
 - REINVENT pretrained modeliyle ligand Ã¼retimi yapÄ±lÄ±r
 - Lipinski kurallarÄ±na gÃ¶re filtreleme
 - ADMET skoru hesaplama
 - Docking (AutoDock Vina)
 - QED + ADMET + Docking skorlamasÄ±
 - En iyi 2 ligand seÃ§ilir, SDF + PNG olarak kaydedilir

GELÄ°ÅžTÄ°RÄ°CÄ° NOTLARI (TÃœRKÃ‡E):
â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
- Bu betik, *de novo* ilaÃ§ tasarÄ±mÄ±nÄ± otomatikleÅŸtiren entegre bir pipelineâ€™dÄ±r.
- Pipeline modÃ¼ler yapÄ±dadÄ±r: her adÄ±m baÄŸÄ±msÄ±z test edilebilir/iyileÅŸtirilebilir.
- Hata yÃ¶netimi (error handling) sÄ±nÄ±rlÄ±dÄ±r â†’ Ã¼retim Ã¶ncesi iyileÅŸtirilmeli.
- REINVENT ve DeepChem modelleri Ã¶nceden eÄŸitilmiÅŸ olmalÄ±dÄ±r; model yollarÄ± doÄŸru olmalÄ±.
- AutoDock Vinaâ€™nÄ±n sistemde kurulu ve PATHâ€™te tanÄ±mlÄ± olmasÄ± gerekir.
- Open Babel baÄŸÄ±mlÄ±lÄ±ÄŸÄ± vardÄ±r â†’ ligand format dÃ¶nÃ¼ÅŸÃ¼mÃ¼ iÃ§in gerekli.
- Paralel iÅŸlem sayÄ±sÄ± (N_CPU) sistemin fiziksel Ã§ekirdek sayÄ±sÄ±na gÃ¶re ayarlanmalÄ±.
- ADMET modelleri DeepChemâ€™in varsayÄ±lan veri dizinine (get_data_dir) baÄŸlÄ±dÄ±r. 
  Bu dizinler Ã¶nceden indirilmemiÅŸse tahmin baÅŸarÄ±sÄ±z olur â†’ model checkpointâ€™leri kontrol edilmeli.
- Docking skorlarÄ± negatif olabilir; â€˜totalâ€™ skor hesaplanÄ±rken dikkatli normalizasyon yapÄ±lmalÄ±.
- Lipinski filtresi "â‰¤1 ihlal" kabul eder (kurala gÃ¶re genellikle 0 ihlal tercih edilir).
  GerektiÄŸinde bu eÅŸik ayarlanabilir (Ã¶rn. `lipinski_threshold = 0`).
- EmbedMolecule optimizasyonu baÅŸarÄ±sÄ±z olabilir â†’ try-except bloÄŸu eklenebilir.
- MolekÃ¼l optimizasyonu iÃ§in MMFF94 kullanÄ±lmÄ±ÅŸtÄ±r; alternatif olarak UFF de deneyebilirsiniz.
- Pipeline, bÃ¼yÃ¼k Ã¶lÃ§ekli Ã¼retimi desteklemek iÃ§in bellek ve disk kullanÄ±mÄ±nÄ± optimize etmelidir.
- Ãœretilen ligandlarÄ±n stereo-kimyasÄ± rastgele olabilir â†’ 3D konformasyonlarda dikkat!
- SonuÃ§ PNGâ€™leri, ligandlarÄ±n kimyasal yapÄ±sÄ±nÄ± net gÃ¶stermeli â†’ gerektiÄŸinde	DrawOptions() ile Ã¶zelleÅŸtirilebilir.
- SDF dosyasÄ±na skor bilgileri (QED, ADMET, Docking) eklenmemiÅŸ â†’ SD etiketleriyle eklenebilir. âœ… (DÃœZELTÄ°LDÄ°!)
- Pipelineâ€™Ä±n tamamlanma sÃ¼resi ligand sayÄ±sÄ± ve CPU sayÄ±sÄ±na doÄŸrusal orantÄ±lÄ± deÄŸildir â†’ bottleneckâ€™lar profil edilmeli.
- GÃ¼nlÃ¼k kaydÄ± (logging) yerine print kullanÄ±lmÄ±ÅŸtÄ±r â†’ Ã¼retim ortamÄ± iÃ§in logging modÃ¼lÃ¼ tercih edilmeli.
- PDB dosyasÄ± iÃ§inde sadece proteine ait atomlar olmalÄ± â†’ su, iyon, kofaktÃ¶r temizliÄŸi Ã¶nerilir.
- Pocket analizinde sadece atom koordinat ortalamasÄ± alÄ±nmÄ±ÅŸ; daha geliÅŸmiÅŸ algoritmalar (Ã¶rn. fpocket) tercih edilebilir.
- Docking kutusu boyutu standart sapmaya gÃ¶re hesaplanmÄ±ÅŸ â†’ bu, kÃ¼Ã§Ã¼k ceplerde yetersiz kalabilir.
  Alternatif: maks-min farkÄ± (range) kullanÄ±larak kutu boyutu belirlenebilir.
- REINVENTâ€™in "sample" fonksiyonu deterministik deÄŸil â†’ tekrarlanabilirlik iÃ§in seed ayarlanmalÄ±.
- ADMET skoru aÄŸÄ±rlÄ±klarÄ± (0.3, 0.2, vb.) kullanÄ±cÄ±ya Ã¶zel olabilir â†’ konfigÃ¼rasyon dosyasÄ±na taÅŸÄ±nabilir.
- Pipeline, ROCm/CUDA destekli GPUâ€™da hÄ±zlandÄ±rÄ±labilir (Ã¶zellikle REINVENT ve DeepChem iÃ§in).
"""

import os
import subprocess
import numpy as np
from rdkit import Chem
from rdkit.Chem import AllChem, Descriptors, Draw, rdMolDescriptors, rdmolfiles
from multiprocessing import Pool
import deepchem as dc

# =====================
# 0. KullanÄ±cÄ± AyarlarÄ±
# =====================
PDB_FILE = "my_pocket.pdb"
VINA_PATH = "vina"  # EÄŸer PATH'te deÄŸilse tam yol verin
OUT_DIR = "top2_results"
MODEL_PATH = "reinvent_model.pt"
NUM_LIGANDS = 200
N_CPU = 4

os.makedirs(OUT_DIR, exist_ok=True)

# =====================
# YardÄ±mcÄ±: ADMET model var mÄ±?
# =====================
def admet_models_exist():
    base = dc.utils.get_data_dir()
    required = ["caco2", "pgp", "cyp3a4", "herg", "hepatotox"]
    for r in required:
        model_dir = os.path.join(base, "admet", r)
        if not os.path.isdir(model_dir):
            print(f" ADMET model eksik: {model_dir}")
            return False
    return True

# =====================
# 1. Pocket Analizi
# =====================
def analyze_pocket(pdb_file):
    mol = rdmolfiles.MolFromPDBFile(pdb_file, removeHs=False)
    if mol is None:
        raise ValueError(f"Pocket dosyasÄ± okunamadÄ±: {pdb_file}")
    conf = mol.GetConformer()
    coords = np.array([list(conf.GetAtomPosition(i)) for i in range(mol.GetNumAtoms())])
    center = np.mean(coords, axis=0)
    size = np.std(coords, axis=0) * 2  # Kutu boyutu iÃ§in standart sapmanÄ±n 2 katÄ±
    print(f"ðŸ§¬ Pocket center = {center}, size = {size}")
    return {'mol': mol, 'center': center, 'size': size}

# =====================
# 2. Lipinski Ä°hlal SayÄ±sÄ±
# =====================
def lipinski_violations(mol):
    mw = Descriptors.MolWt(mol)
    logp = Descriptors.MolLogP(mol)
    hbd = rdMolDescriptors.CalcNumHBD(mol)
    hba = rdMolDescriptors.CalcNumHBA(mol)
    violations = sum([
        mw > 500,
        logp > 5,
        hbd > 5,
        hba > 10
    ])
    return violations

# =====================
# 3. ADMET Skoru
# =====================
def calc_admet_score(mol):
    smi = Chem.MolToSmiles(mol)
    featurizer = dc.feat.MolGraphConvFeaturizer()
    try:
        mol_feat = featurizer.featurize([smi])
    except:
        return 0.5

    base = dc.utils.get_data_dir()
    model_paths = {
        "caco2": os.path.join(base, "admet", "caco2"),
        "pgp": os.path.join(base, "admet", "pgp"),
        "cyp3a4": os.path.join(base, "admet", "cyp3a4"),
        "herg": os.path.join(base, "admet", "herg"),
        "hepatotox": os.path.join(base, "admet", "hepatotox")
    }

    preds = {}
    for name, path in model_paths.items():
        try:
            model = dc.models.GraphConvModel.load_from_dir(path)
            preds[name] = float(model.predict(mol_feat)[0][0])
        except Exception as e:
            print(f" ADMET model yÃ¼klenemedi ({name}): {e}")
            preds[name] = 0.5

    absorption = preds["caco2"]
    distribution = 1 - preds["pgp"]
    metabolism = 1 - preds["cyp3a4"]
    toxicity = (1 - preds["herg"]) * (1 - preds["hepatotox"])
    admet_score = 0.3 * absorption + 0.2 * distribution + 0.2 * metabolism + 0.3 * toxicity
    return max(0.0, min(1.0, admet_score))

# =====================
# 4. Ligand Ãœretimi (REINVENT)
# =====================
def generate_ligands_reinvent(num_ligands, model_path):
    print(" REINVENT modeli yÃ¼kleniyor...")
    try:
        from reinvent.models import Model
        model = Model.load_from_file(model_path)
    except Exception as e:
        raise RuntimeError(f"REINVENT modeli yÃ¼klenemedi: {e}")

    ligands = []
    for i in range(num_ligands):
        try:
            smi = model.sample()
        except Exception:
            continue
        mol = Chem.MolFromSmiles(smi)
        if mol is None:
            continue
        mol = Chem.AddHs(mol)
        try:
            AllChem.EmbedMolecule(mol, randomSeed=i, maxAttempts=10)
            AllChem.MMFFOptimizeMolecule(mol)
        except:
            continue

        ligands.append({
            'smiles': smi,
            'mol': mol
        })
    print(f" {len(ligands)} geÃ§erli ligand Ã¼retildi.")
    return ligands

# =====================
# 5. Docking HazÄ±rlÄ±ÄŸÄ± ve Ã‡alÄ±ÅŸtÄ±rma
# =====================
def prepare_ligand_for_vina(mol, name_prefix, out_dir):
    mol2_file = os.path.join(out_dir, f"{name_prefix}.mol2")
    pdbqt_file = os.path.join(out_dir, f"{name_prefix}.pdbqt")
    Chem.MolToMol2File(mol, mol2_file)
    cmd = ["obabel", mol2_file, "-O", pdbqt_file, "-xp"]
    try:
        subprocess.run(cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, check=True)
    except subprocess.CalledProcessError:
        return None
    return pdbqt_file

def dock_ligand(args):
    i, ligand, pocket, pdb_file, out_dir, vina_path = args
    name_prefix = f"lig_{i}"
    pdbqt_file = prepare_ligand_for_vina(ligand['mol'], name_prefix, out_dir)
    if pdbqt_file is None:
        return (i, 999.0)

    out_pdbqt = os.path.join(out_dir, f"{name_prefix}_vina_out.pdbqt")
    out_log = os.path.join(out_dir, f"{name_prefix}_vina_out.txt")

    x, y, z = pocket['center']
    sx, sy, sz = pocket['size']

    cmd = [
        vina_path,
        "--receptor", pdb_file,
        "--ligand", pdbqt_file,
        "--center_x", f"{x:.3f}",
        "--center_y", f"{y:.3f}",
        "--center_z", f"{z:.3f}",
        "--size_x", f"{sx:.3f}",
        "--size_y", f"{sy:.3f}",
        "--size_z", f"{sz:.3f}",
        "--out", out_pdbqt,
        "--log", out_log
    ]

    try:
        subprocess.run(cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, timeout=120)
    except subprocess.TimeoutExpired:
        return (i, 999.0)

    score = 999.0
    try:
        with open(out_log, "r") as f:
            for line in f:
                if line.strip().startswith("REMARK VINA RESULT:"):
                    parts = line.strip().split()
                    if len(parts) >= 4:
                        try:
                            score = float(parts[3])
                            break
                        except ValueError:
                            pass
    except FileNotFoundError:
        pass
    return (i, score)

# =====================
# 6. Ana Ä°ÅŸlem
# =====================
def main():
    print("TAM Pipeline BaÅŸlatÄ±lÄ±yor...")
    
    # ADMET modelleri kontrolÃ¼
    if not admet_models_exist():
        print("ADMET modelleri eksik. LÃ¼tfen DeepChem ADMET modellerini indirin.")
        return

    # Pocket analizi
    pocket = analyze_pocket(PDB_FILE)

    # Ligand Ã¼retimi
    ligands = generate_ligands_reinvent(NUM_LIGANDS, MODEL_PATH)

    # Lipinski filtresi (â‰¤1 ihlal)
    ligands = [l for l in ligands if lipinski_violations(l['mol']) <= 1]
    print(f" {len(ligands)} ligand Lipinski (â‰¤1 ihlal) filtresinden geÃ§ti.")

    if len(ligands) == 0:
        print("Filtreden geÃ§en ligand yok!")
        return

    # ADMET skoru hesaplama
    print("ADMET skorlarÄ± hesaplanÄ±yor...")
    for l in ligands:
        l['admet'] = calc_admet_score(l['mol'])

    # Lipinski skoru hesaplama (0 ihlal = 1.0, 1 ihlal = 0.5)
    for l in ligands:
        v = lipinski_violations(l['mol'])
        l['lipinski_score'] = 1.0 if v == 0 else (0.5 if v == 1 else 0.0)

    # Docking (paralel)
    print("ðŸ”¬ Docking baÅŸlatÄ±lÄ±yor...")
    dock_args = [
        (i, l, pocket, PDB_FILE, OUT_DIR, VINA_PATH)
        for i, l in enumerate(ligands)
    ]
    with Pool(N_CPU) as pool:
        docking_results = pool.map(dock_ligand, dock_args)

    for i, score in docking_results:
        ligands[i]['dock_score'] = score

    # Toplam skor hesaplama
    for l in ligands:
        # Docking: dÃ¼ÅŸÃ¼k = iyi â†’ ters orantÄ±lÄ± normalizasyon
        dock_norm = max(0.0, min(1.0, (20.0 - max(l['dock_score'], -20.0)) / 40.0))
        l['total'] = 0.4 * l['admet'] + 0.3 * l['lipinski_score'] + 0.3 * dock_norm

    # En iyi 2 ligand
    top2 = sorted(ligands, key=lambda x: x['total'], reverse=True)[:2]

    # SDF kaydet (skorlarla birlikte) 
    sdf_file = os.path.join(OUT_DIR, "top2.sdf")
    writer = Chem.SDWriter(sdf_file)
    for l in top2:
        mol = l['mol']
        mol.SetProp("SMILES", l['smiles'])
        mol.SetProp("ADMET_Score", f"{l['admet']:.3f}")
        mol.SetProp("Docking_Score", f"{l['dock_score']:.3f}")
        mol.SetProp("Lipinski_Violations", str(lipinski_violations(l['mol'])))
        mol.SetProp("Total_Score", f"{l['total']:.3f}")
        writer.write(mol)
    writer.close()

    # PNG gÃ¶rselleÅŸtirme
    legends = [
        f"Dock={l['dock_score']:.2f}\nADMET={l['admet']:.2f}\nLipinski={lipinski_violations(l['mol'])} ihlal\nTotal={l['total']:.2f}"
        for l in top2
    ]
    img = Draw.MolsToGridImage(
        [l['mol'] for l in top2],
        molsPerRow=2,
        subImgSize=(400, 400),
        legends=legends
    )
    img.save(os.path.join(OUT_DIR, "top2_ligands.png"))

    # SonuÃ§ yazdÄ±rma
    print("\n En iyi 2 ligand:")
    for i, l in enumerate(top2, 1):
        v = lipinski_violations(l['mol'])
        print(f"{i}. {l['smiles']}")
        print(f"   Dock={l['dock_score']:.2f} | ADMET={l['admet']:.2f} | Lipinski ihlal={v} | Total={l['total']:.2f}")

    print(f"\n SonuÃ§lar '{OUT_DIR}' klasÃ¶rÃ¼nde kaydedildi.")


# =====================
if __name__ == "__main__":
    main()
