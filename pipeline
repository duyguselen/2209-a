#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
MASTER PIPELINE:  
1. REINVENT RL ile √∂d√ºl odaklƒ± ligand √ºretimi (Lipinski + ADMET + Cep uyumu)
2. Ger√ßek AutoDock Vina docking + DeepChem ADMET + Son skorlama
3. En iyi 2 ligandƒ± SDF + PNG olarak kaydet

Yazar: Duygu ƒ∞rem √ñzger

GELƒ∞≈ûTƒ∞Rƒ∞Cƒ∞ NOTLARI (T√úRK√áE):
‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
- Bu betik, *de novo* ila√ß tasarƒ±mƒ±nƒ± otomatikle≈ütiren entegre bir pipeline‚Äôdƒ±r.
- Pipeline mod√ºler yapƒ±dadƒ±r: her adƒ±m baƒüƒ±msƒ±z test edilebilir/iyile≈ütirilebilir.
- Hata y√∂netimi (error handling) sƒ±nƒ±rlƒ±dƒ±r ‚Üí √ºretim √∂ncesi iyile≈ütirilmeli.
- REINVENT ve DeepChem modelleri √∂nceden eƒüitilmi≈ü olmalƒ±dƒ±r; model yollarƒ± doƒüru olmalƒ±.
- AutoDock Vina‚Äônƒ±n sistemde kurulu ve PATH‚Äôte tanƒ±mlƒ± olmasƒ± gerekir.
- Open Babel baƒüƒ±mlƒ±lƒ±ƒüƒ± vardƒ±r ‚Üí ligand format d√∂n√º≈ü√ºm√º i√ßin gerekli.
- Paralel i≈ülem sayƒ±sƒ± (N_CPU) sistemin fiziksel √ßekirdek sayƒ±sƒ±na g√∂re ayarlanmalƒ±.
- ADMET modelleri DeepChem‚Äôin varsayƒ±lan veri dizinine (get_data_dir) baƒülƒ±dƒ±r. 
  Bu dizinler √∂nceden indirilmemi≈üse tahmin ba≈üarƒ±sƒ±z olur ‚Üí model checkpoint‚Äôleri kontrol edilmeli.
- Docking skorlarƒ± negatif olabilir; ‚Äòtotal‚Äô skor hesaplanƒ±rken dikkatli normalizasyon yapƒ±lmalƒ±.
- Lipinski filtresi "‚â§1 ihlal" kabul eder (kurala g√∂re genellikle 0 ihlal tercih edilir).
  Gerektiƒüinde bu e≈üik ayarlanabilir (√∂rn. `lipinski_threshold = 0`).
- EmbedMolecule optimizasyonu ba≈üarƒ±sƒ±z olabilir ‚Üí try-except bloƒüu eklenebilir.
- Molek√ºl optimizasyonu i√ßin MMFF94 kullanƒ±lmƒ±≈ütƒ±r; alternatif olarak UFF de deneyebilirsiniz.
- Pipeline, b√ºy√ºk √∂l√ßekli √ºretimi desteklemek i√ßin bellek ve disk kullanƒ±mƒ±nƒ± optimize etmelidir.
- √úretilen ligandlarƒ±n stereo-kimyasƒ± rastgele olabilir ‚Üí 3D konformasyonlarda dikkat!
- Sonu√ß PNG‚Äôleri, ligandlarƒ±n kimyasal yapƒ±sƒ±nƒ± net g√∂stermeli ‚Üí gerektiƒüinde	DrawOptions() ile √∂zelle≈ütirilebilir.
- SDF dosyasƒ±na skor bilgileri (QED, ADMET, Docking) eklenmi≈ütir ‚Üí SD etiketleriyle kaydedilir. 
- Pipeline, ROCm/CUDA destekli GPU‚Äôda hƒ±zlandƒ±rƒ±labilir (√∂zellikle REINVENT ve DeepChem i√ßin).
- G√ºnl√ºk kaydƒ± (logging) yerine print kullanƒ±lmƒ±≈ütƒ±r ‚Üí √ºretim ortamƒ± i√ßin logging mod√ºl√º tercih edilmeli.
- PDB dosyasƒ± i√ßinde sadece proteine ait atomlar olmalƒ± ‚Üí su, iyon, kofakt√∂r temizliƒüi √∂nerilir.
- Pocket analizinde sadece atom koordinat ortalamasƒ± alƒ±nmƒ±≈ü; daha geli≈ümi≈ü algoritmalar (√∂rn. fpocket) tercih edilebilir.
- Docking kutusu boyutu standart sapmaya g√∂re hesaplanmƒ±≈ü ‚Üí bu, k√º√ß√ºk ceplerde yetersiz kalabilir.
  Alternatif: maks-min farkƒ± (range) kullanƒ±larak kutu boyutu belirlenebilir.
- REINVENT‚Äôin "sample" fonksiyonu deterministik deƒüil ‚Üí tekrarlanabilirlik i√ßin seed ayarlanmalƒ±.
  RL modunda `randomSeed` kullanƒ±mƒ± √∂nerilir.
- ADMET skoru aƒüƒ±rlƒ±klarƒ± (0.3, 0.2, vb.) kullanƒ±cƒ±ya √∂zel olabilir ‚Üí konfig√ºrasyon dosyasƒ±na ta≈üƒ±nabilir.
- Pipeline‚Äôƒ±n tamamlanma s√ºresi ligand sayƒ±sƒ± ve CPU sayƒ±sƒ±na doƒürusal orantƒ±lƒ± deƒüildir ‚Üí bottleneck‚Äôlar profil edilmeli.
- RL a≈üamasƒ± (`RL_NUM_STEPS`) varsayƒ±lan olarak 100‚Äôt√ºr. Hƒ±zlƒ± testler i√ßin 10, 
  ger√ßek √ºretimde 100‚Äì500 arasƒ± √∂nerilir. Adƒ±m sayƒ±sƒ± arttƒ±k√ßa molek√ºller √∂d√ºl fonksiyonuna daha iyi uyarlanƒ±r.
- RL √ßƒ±kƒ±≈üƒ±ndaki molek√ºller h√¢l√¢ post-hoc docking ile doƒürulanmalƒ±dƒ±r ‚Üí "proxy reward ‚â† ger√ßek etkinlik".
- Bu pipeline, hibrit bir yakla≈üƒ±m sunar: 
    ‚Ä¢ Akƒ±llƒ± √ºretim (REINVENT RL) + 
    ‚Ä¢ Fiziksel doƒürulama (Vina) + 
    ‚Ä¢ Farmakokinetik g√ºven (ADMET).
"""

import os
import subprocess
import numpy as np
from rdkit import Chem
from rdkit.Chem import AllChem, Descriptors, Draw, rdMolDescriptors, rdmolfiles
from multiprocessing import Pool
import deepchem as dc

# ================
# Kullanƒ±cƒ± Ayarlarƒ±
# ================
PDB_FILE = "my_pocket.pdb"
PRIOR_MODEL_PATH = "reinvent.prior"
RL_OUTPUT_DIR = "rl_results"
RL_TOP_N = 50          # RL'den ka√ß molek√ºl alƒ±nacak?
RL_NUM_STEPS = 100     # üí° RL adƒ±mƒ±: Hƒ±zlƒ± test i√ßin 10, ger√ßek √ºretimde 100-500 √∂nerilir
FINAL_OUT_DIR = "final_top2"
N_CPU = 4

os.makedirs(FINAL_OUT_DIR, exist_ok=True)

# ===================================================
# A≈ûAMA 1: REINVENT RL ile √ñd√ºl Odaklƒ± √úretim
# ===================================================
def run_reinvent_rl():
    print("A≈ûAMA 1: REINVENT RL ile √∂d√ºl odaklƒ± √ºretim ba≈ülatƒ±lƒ±yor...")
    
    try:
        from reinvent.models import Model
        from reinvent.runmodes import ReinforcementLearning
        from reinvent.scoring import ScoringFunction
        from reinvent.scoring.scoring_components import CustomComponent
    except ImportError:
        raise RuntimeError("REINVENT kurulu deƒüil. L√ºtfen MolecularAI/Reinvent'i kurun.")

    # Pocket merkezi
    mol = rdmolfiles.MolFromPDBFile(PDB_FILE, removeHs=False)
    if mol is None:
        raise ValueError(f"Pocket dosyasƒ± okunamadƒ±: {PDB_FILE}")
    conf = mol.GetConformer()
    coords = np.array([list(conf.GetAtomPosition(i)) for i in range(mol.GetNumAtoms())])
    POCKET_CENTER = np.mean(coords, axis=0)

    # Yardƒ±mcƒ± skor fonksiyonlarƒ±
    def lipinski_score(mol):
        v = sum([
            Descriptors.MolWt(mol) > 500,
            Descriptors.MolLogP(mol) > 5,
            rdMolDescriptors.CalcNumHBD(mol) > 5,
            rdMolDescriptors.CalcNumHBA(mol) > 10
        ])
        return 1.0 if v == 0 else (0.5 if v == 1 else 0.0)

    def admet_score(mol):
        smi = Chem.MolToSmiles(mol)
        featurizer = dc.feat.MolGraphConvFeaturizer()
        try:
            feat = featurizer.featurize([smi])
        except:
            return 0.0
        base = dc.utils.get_data_dir()
        score = 0.0
        weights = {"caco2": 0.3, "pgp": -0.2, "cyp3a4": -0.2, "herg": -0.15, "hepatotox": -0.15}
        for name, w in weights.items():
            try:
                model = dc.models.GraphConvModel.load_from_dir(os.path.join(base, "admet", name))
                pred = float(model.predict(feat)[0][0])
                score += w * pred if w < 0 else w * (1 - pred)
            except:
                pass
        return max(0.0, min(1.0, score))

    def pocket_proximity_score(mol, center):
        mol = Chem.AddHs(mol)
        if AllChem.EmbedMolecule(mol, randomSeed=42) != 0:
            return 0.0
        AllChem.MMFFOptimizeMolecule(mol)
        conf = mol.GetConformer()
        coords = np.array([list(conf.GetAtomPosition(i)) for i in range(mol.GetNumAtoms())])
        avg_dist = np.mean(np.linalg.norm(coords - center, axis=1))
        return max(0.0, 1.0 - avg_dist / 15.0)

    def custom_reward(smiles_list):
        rewards = []
        for smi in smiles_list:
            mol = Chem.MolFromSmiles(smi)
            if mol is None:
                rewards.append(0.0)
                continue
            l = lipinski_score(mol)
            a = admet_score(mol)
            p = pocket_proximity_score(mol, POCKET_CENTER)
            rewards.append(0.4*a + 0.3*l + 0.3*p)
        return np.array(rewards)

    # Modeller
    prior = Model.load_from_file(PRIOR_MODEL_PATH)
    agent = prior.make_copy()

    # Scoring
    component = CustomComponent(custom_reward, "RL_Reward", weight=1.0)
    scoring_function = ScoringFunction([component], [1.0])

      # RL √ßalƒ±≈ütƒ±r
    rl = ReinforcementLearning(
        configuration={"parameters": {
            "scoring_function": scoring_function,
            "num_steps": RL_NUM_STEPS,   # Artƒ±k yapƒ±landƒ±rƒ±labilir
            "batch_size": 64,
            "sigma": 64,
            "learning_rate": 0.0001
        }},
        agent=agent,
        prior=prior,
        output_directory=RL_OUTPUT_DIR
    )
    rl.run()

    # En iyi 50 molek√ºl√º al
    top_smiles = rl.get_top_50_smiles(n=RL_TOP_50)
    smiles_list = [smi for smi, 50 in top_smiles]
    
    print(f"RL tamamlandƒ±. {len(smiles_list)} molek√ºl se√ßildi.")
    return smiles_list

# ===================================================
# A≈ûAMA 2: Ger√ßek ADMET + Docking + Son Skorlama
# ===================================================

def lipinski_violations(mol):
    return sum([
        Descriptors.MolWt(mol) > 500,
        Descriptors.MolLogP(mol) > 5,
        rdMolDescriptors.CalcNumHBD(mol) > 5,
        rdMolDescriptors.CalcNumHBA(mol) > 10
    ])

def calc_admet_score_final(mol):
    smi = Chem.MolToSmiles(mol)
    featurizer = dc.feat.MolGraphConvFeaturizer()
    try:
        mol_feat = featurizer.featurize([smi])
    except:
        return 0.5

    base = dc.utils.get_data_dir()
    model_paths = {
        "caco2": os.path.join(base, "admet", "caco2"),
        "pgp": os.path.join(base, "admet", "pgp"),
        "cyp3a4": os.path.join(base, "admet", "cyp3a4"),
        "herg": os.path.join(base, "admet", "herg"),
        "hepatotox": os.path.join(base, "admet", "hepatotox")
    }

    preds = {}
    for name, path in model_paths.items():
        try:
            model = dc.models.GraphConvModel.load_from_dir(path)
            preds[name] = float(model.predict(mol_feat)[0][0])
        except:
            preds[name] = 0.5

    absorption = preds["caco2"]
    distribution = 1 - preds["pgp"]
    metabolism = 1 - preds["cyp3a4"]
    toxicity = (1 - preds["herg"]) * (1 - preds["hepatotox"])
    return max(0.0, min(1.0, 0.3*absorption + 0.2*distribution + 0.2*metabolism + 0.3*toxicity))

def analyze_pocket(pdb_file):
    mol = rdmolfiles.MolFromPDBFile(pdb_file, removeHs=False)
    conf = mol.GetConformer()
    coords = np.array([list(conf.GetAtomPosition(i)) for i in range(mol.GetNumAtoms())])
    center = np.mean(coords, axis=0)
    size = np.std(coords, axis=0) * 2
    return {'mol': mol, 'center': center, 'size': size}

def prepare_ligand_for_vina(mol, name_prefix, out_dir):
    mol2 = os.path.join(out_dir, f"{name_prefix}.mol2")
    pdbqt = os.path.join(out_dir, f"{name_prefix}.pdbqt")
    Chem.MolToMol2File(mol, mol2)
    cmd = ["obabel", mol2, "-O", pdbqt, "-xp"]
    subprocess.run(cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
    return pdbqt

def dock_ligand(args):
    i, mol, pocket, pdb_file, out_dir = args
    name = f"mol_{i}"
    pdbqt = prepare_ligand_for_vina(mol, name, out_dir)
    out_pdbqt = os.path.join(out_dir, f"{name}_out.pdbqt")
    out_log = os.path.join(out_dir, f"{name}_out.log")

    x, y, z = pocket['center']
    sx, sy, sz = pocket['size']

    cmd = [
        "vina",
        "--receptor", pdb_file,
        "--ligand", pdbqt,
        "--center_x", f"{x:.3f}",
        "--center_y", f"{y:.3f}",
        "--center_z", f"{z:.3f}",
        "--size_x", f"{sx:.3f}",
        "--size_y", f"{sy:.3f}",
        "--size_z", f"{sz:.3f}",
        "--out", out_pdbqt,
        "--log", out_log
    ]
    subprocess.run(cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, timeout=120)

    score = 999.0
    try:
        with open(out_log) as f:
            for line in f:
                if "REMARK VINA RESULT:" in line:
                    score = float(line.split()[3])
                    break
    except:
        pass
    return (i, score)

def main():
    print("MASTER PIPELINE: RL + Ger√ßek Docking + Final Se√ßim")
    
    # A≈ûAMA 1: RL √úretimi
    smiles_list = run_reinvent_rl()
    
    # Molek√ºlleri hazƒ±rla
    ligands = []
    for i, smi in enumerate(smiles_list):
        mol = Chem.MolFromSmiles(smi)
        if mol is None:
            continue
        mol = Chem.AddHs(mol)
        if AllChem.EmbedMolecule(mol, randomSeed=i) == 0:
            AllChem.MMFFOptimizeMolecule(mol)
            ligands.append({'smiles': smi, 'mol': mol})

    # Lipinski filtresi
    ligands = [l for l in ligands if lipinski_violations(l['mol']) <= 1]
    print(f"{len(ligands)} ligand Lipinski filtresinden ge√ßti.")

    if not ligands:
        raise RuntimeError("Filtreden ge√ßen ligand yok!")

    # ADMET
    print("Ger√ßek ADMET skorlarƒ± hesaplanƒ±yor...")
    for l in ligands:
        l['admet'] = calc_admet_score_final(l['mol'])

    # Lipinski skoru
    for l in ligands:
        v = lipinski_violations(l['mol'])
        l['lipinski_score'] = 1.0 if v == 0 else 0.5

    # Docking
    print("üî¨ Ger√ßek AutoDock Vina docking ba≈ülatƒ±lƒ±yor...")
    pocket = analyze_pocket(PDB_FILE)
    dock_args = [(i, l['mol'], pocket, PDB_FILE, FINAL_OUT_DIR) for i, l in enumerate(ligands)]
    with Pool(N_CPU) as pool:
        results = pool.map(dock_ligand, dock_args)
    for i, score in results:
        ligands[i]['dock_score'] = score

    # Final skor (docking d√º≈ü√ºk = iyi ‚Üí ters normalize)
    for l in ligands:
        dock_norm = max(0.0, min(1.0, (20.0 - max(l['dock_score'], -20.0)) / 40.0))
        l['total'] = 0.4*l['admet'] + 0.3*l['lipinski_score'] + 0.3*dock_norm

    # En iyi 2
    top2 = sorted(ligands, key=lambda x: x['total'], reverse=True)[:2]

    # Kaydet
    writer = Chem.SDWriter(os.path.join(FINAL_OUT_DIR, "top2.sdf"))
    for l in top2:
        mol = l['mol']
        mol.SetProp("SMILES", l['smiles'])
        mol.SetProp("ADMET_Score", f"{l['admet']:.3f}")
        mol.SetProp("Docking_Score", f"{l['dock_score']:.3f}")
        mol.SetProp("Lipinski_Violations", str(lipinski_violations(l['mol'])))
        mol.SetProp("Total_Score", f"{l['total']:.3f}")
        writer.write(mol)
    writer.close()

    # PNG
    legends = [
        f"Dock={l['dock_score']:.2f}\nADMET={l['admet']:.2f}\nLipinski={lipinski_violations(l['mol'])} ihlal"
        for l in top2
    ]
    img = Draw.MolsToGridImage([l['mol'] for l in top2], molsPerRow=2, subImgSize=(400,400), legends=legends)
    img.save(os.path.join(FINAL_OUT_DIR, "top2_ligands.png"))

    print("\n EN ƒ∞Yƒ∞ 2 Lƒ∞GAND:")
    for i, l in enumerate(top2, 1):
        v = lipinski_violations(l['mol'])
        print(f"{i}. {l['smiles']}")
        print(f"   Dock: {l['dock_score']:.2f} | ADMET: {l['admet']:.2f} | Lipinski: {v} ihlal")

    print(f"\n Sonu√ßlar: {FINAL_OUT_DIR}/")

if __name__ == "__main__":
    main()
