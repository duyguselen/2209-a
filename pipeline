#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
TAM PIPELINE: REINVENT ile cep modeline uygun molekÃ¼l tasarÄ±mÄ± + Lipinski kurallarÄ± + ADMET skorlarÄ± + Docking
Yazar: Duygu Ä°rem Ã–zger
AÃ§Ä±klama:
 - KullanÄ±cÄ± tarafÄ±ndan verilen cep PDB'den merkez ve boyut hesaplanÄ±r
 - REINVENT pretrained modeliyle ligand Ã¼retimi yapÄ±lÄ±r
 - Lipinski kurallarÄ±na gÃ¶re filtreleme
 - ADMET skoru hesaplama
 - Docking (AutoDock Vina)
 - QED + ADMET + Docking skorlamasÄ±
 - En iyi 2 ligand seÃ§ilir, SDF + PNG olarak kaydedilir

ğŸ¯ GELÄ°ÅTÄ°RÄ°CÄ° NOTLARI (TÃœRKÃ‡E):
â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
- Bu betik, *de novo* ilaÃ§ tasarÄ±mÄ±nÄ± otomatikleÅŸtiren entegre bir pipelineâ€™dÄ±r.
- Pipeline modÃ¼ler yapÄ±dadÄ±r: her adÄ±m baÄŸÄ±msÄ±z test edilebilir/iyileÅŸtirilebilir.
- Hata yÃ¶netimi (error handling) sÄ±nÄ±rlÄ±dÄ±r â†’ Ã¼retim Ã¶ncesi iyileÅŸtirilmeli.
- REINVENT ve DeepChem modelleri Ã¶nceden eÄŸitilmiÅŸ olmalÄ±dÄ±r; model yollarÄ± doÄŸru olmalÄ±.
- AutoDock Vinaâ€™nÄ±n sistemde kurulu ve PATHâ€™te tanÄ±mlÄ± olmasÄ± gerekir.
- Open Babel baÄŸÄ±mlÄ±lÄ±ÄŸÄ± vardÄ±r â†’ ligand format dÃ¶nÃ¼ÅŸÃ¼mÃ¼ iÃ§in gerekli.
- Paralel iÅŸlem sayÄ±sÄ± (N_CPU) sistemin fiziksel Ã§ekirdek sayÄ±sÄ±na gÃ¶re ayarlanmalÄ±.
- ADMET modelleri DeepChemâ€™in varsayÄ±lan veri dizinine (get_data_dir) baÄŸlÄ±dÄ±r. 
  Bu dizinler Ã¶nceden indirilmemiÅŸse tahmin baÅŸarÄ±sÄ±z olur â†’ model checkpointâ€™leri kontrol edilmeli.
- Docking skorlarÄ± negatif olabilir; â€˜totalâ€™ skor hesaplanÄ±rken dikkatli normalizasyon yapÄ±lmalÄ±.
- Lipinski filtresi "â‰¤1 ihlal" kabul eder (kurala gÃ¶re genellikle 0 ihlal tercih edilir).
  GerektiÄŸinde bu eÅŸik ayarlanabilir (Ã¶rn. `lipinski_threshold = 0`).
- EmbedMolecule optimizasyonu baÅŸarÄ±sÄ±z olabilir â†’ try-except bloÄŸu eklenebilir.
- MolekÃ¼l optimizasyonu iÃ§in MMFF94 kullanÄ±lmÄ±ÅŸtÄ±r; alternatif olarak UFF de deneyebilirsiniz.
- Pipeline, bÃ¼yÃ¼k Ã¶lÃ§ekli Ã¼retimi desteklemek iÃ§in bellek ve disk kullanÄ±mÄ±nÄ± optimize etmelidir.
- Ãœretilen ligandlarÄ±n stereo-kimyasÄ± rastgele olabilir â†’ 3D konformasyonlarda dikkat!
- SonuÃ§ PNGâ€™leri, ligandlarÄ±n kimyasal yapÄ±sÄ±nÄ± net gÃ¶stermeli â†’ gerektiÄŸinde	DrawOptions() ile Ã¶zelleÅŸtirilebilir.
- SDF dosyasÄ±na skor bilgileri (QED, ADMET, Docking) eklenmemiÅŸ â†’ SD etiketleriyle eklenebilir.
- Pipeline, ROCm/CUDA destekli GPUâ€™da hÄ±zlandÄ±rÄ±labilir (Ã¶zellikle REINVENT ve DeepChem iÃ§in).
- GÃ¼nlÃ¼k kaydÄ± (logging) yerine print kullanÄ±lmÄ±ÅŸtÄ±r â†’ Ã¼retim ortamÄ± iÃ§in logging modÃ¼lÃ¼ tercih edilmeli.
- PDB dosyasÄ± iÃ§inde sadece proteine ait atomlar olmalÄ± â†’ su, iyon, kofaktÃ¶r temizliÄŸi Ã¶nerilir.
- Pocket analizinde sadece atom koordinat ortalamasÄ± alÄ±nmÄ±ÅŸ; daha geliÅŸmiÅŸ algoritmalar (Ã¶rn. fpocket) tercih edilebilir.
- Docking kutusu boyutu standart sapmaya gÃ¶re hesaplanmÄ±ÅŸ â†’ bu, kÃ¼Ã§Ã¼k ceplerde yetersiz kalabilir.
  Alternatif: maks-min farkÄ± (range) kullanÄ±larak kutu boyutu belirlenebilir.
- REINVENTâ€™in "sample" fonksiyonu deterministik deÄŸil â†’ tekrarlanabilirlik iÃ§in seed ayarlanmalÄ±.
- ADMET skoru aÄŸÄ±rlÄ±klarÄ± (0.3, 0.2, vb.) kullanÄ±cÄ±ya Ã¶zel olabilir â†’ konfigÃ¼rasyon dosyasÄ±na taÅŸÄ±nabilir.
- Pipelineâ€™Ä±n tamamlanma sÃ¼resi ligand sayÄ±sÄ± ve CPU sayÄ±sÄ±na doÄŸrusal orantÄ±lÄ± deÄŸildir â†’ bottleneckâ€™lar profil edilmeli.
"""

import os
import subprocess
import numpy as np
from rdkit import Chem
from rdkit.Chem import AllChem, Descriptors, QED, Draw, rdMolDescriptors, rdmolfiles
from multiprocessing import Pool
from reinvent import load_model
from reinvent.models.scoring import ScoringFunctionFactory
import deepchem as dc

# =====================
# 0. KullanÄ±cÄ± AyarlarÄ±
# =====================
# ğŸ“Œ GELÄ°ÅTÄ°RÄ°CÄ° NOTU:
# Bu ayarlar bir config dosyasÄ±ndan (JSON/YAML) okunabilir.
# BÃ¶ylece betik her seferinde elle dÃ¼zenlenmek zorunda kalmaz.
PDB_FILE = "my_pocket.pdb"
VINA_PATH = "/usr/local/bin/vina"
OUT_DIR = "top2_results"
MODEL_PATH = "reinvent_model.pt"
NUM_LIGANDS = 200
N_CPU = 4

os.makedirs(OUT_DIR, exist_ok=True)

# =====================
# 1. Pocket Analizi
# =====================
def analyze_pocket(pdb_file):
    # ğŸ“Œ GELÄ°ÅTÄ°RÄ°CÄ° NOTU:
    # Bu fonksiyon sadece koordinat ortalamasÄ±nÄ± alÄ±r.
    # Daha geliÅŸmiÅŸ analiz iÃ§in fpocket, PyVOL veya POVME kullanÄ±labilir.
    mol = rdmolfiles.MolFromPDBFile(pdb_file, removeHs=False)
    if mol is None:
        raise ValueError(f" Pocket dosyasÄ± okunamadÄ±: {pdb_file}")
    conf = mol.GetConformer()
    coords = np.array([list(conf.GetAtomPosition(i)) for i in range(mol.GetNumAtoms())])
    center = np.mean(coords, axis=0)
    size = np.std(coords, axis=0)
    print(f"ğŸ“¦ Pocket center = {center}, size = {size*2}")
    return {'mol': mol, 'center': center, 'size': size}

# =====================
# 2. Ligand Ãœretimi (REINVENT)
# =====================
def generate_ligands_reinvent(num_ligands):
    # ğŸ“Œ GELÄ°ÅTÄ°RÄ°CÄ° NOTU:
    # REINVENT modeli bÃ¼yÃ¼k bellek tÃ¼ketebilir.
    # Ãœretim dÃ¶ngÃ¼sÃ¼nde her iterasyonda model yeniden yÃ¼klenmiyor â†’ iyi.
    # Ancak scoring_function sadece QEDâ€™e dayalÄ± â†’ daha zengin scoring (Ã¶rn. pharmacophore) eklenebilir.
    print(" REINVENT modeli yÃ¼kleniyor...")
    model = load_model(MODEL_PATH)
    scoring_function = ScoringFunctionFactory().from_config({"name": "QEDScore"})
    
    ligands = []
    for i in range(num_ligands):
        smi = model.sample(scoring_function=scoring_function)
        mol = Chem.MolFromSmiles(smi)
        if mol is None:
            continue
        mol = Chem.AddHs(mol)
        # ğŸ“Œ GELÄ°ÅTÄ°RÄ°CÄ° NOTU: EmbedMolecule baÅŸarÄ±sÄ±z olursa mol geÃ§ersiz kalÄ±r.
        # Ä°yileÅŸtirme: try-except + tekrar deneme mekanizmasÄ± eklenebilir.
        AllChem.EmbedMolecule(mol, randomSeed=i)
        AllChem.MMFFOptimizeMolecule(mol)
        ligands.append({'smiles': smi, 'mol': mol})
    print(f" {len(ligands)} ligand Ã¼retildi.")
    return ligands

# =====================
# 3. Lipinski Filtresi
# =====================
def lipinski_violations(mol):
    # ğŸ“Œ GELÄ°ÅTÄ°RÄ°CÄ° NOTU:
    # Klasik "Rule of Five" uygulanmÄ±ÅŸ.
    # GÃ¼nÃ¼mÃ¼zde bu kurallar esnekleÅŸtirilebilir (Ã¶rn. doÄŸal Ã¼rÃ¼nler iÃ§in).
    # Ä°stenirse Ghose, Veber veya MDDR kurallarÄ± da eklenebilir.
    mw = Descriptors.MolWt(mol)
    logp = Descriptors.MolLogP(mol)
    hbd = rdMolDescriptors.CalcNumHBD(mol)
    hba = rdMolDescriptors.CalcNumHBA(mol)
    v = 0
    if mw > 500: v += 1
    if logp > 5: v += 1
    if hbd > 5: v += 1
    if hba > 10: v += 1
    return v

# =====================
# 4. GeliÅŸtirilmiÅŸ ADMET Hesaplama
# =====================
def calc_admet_score(mol):
    """DeepChem tabanlÄ± 5 parametreli ADMET tahmini."""
    # ğŸ“Œ GELÄ°ÅTÄ°RÄ°CÄ° NOTU:
    # DeepChem modelleri Ã¶nceden eÄŸitilmiÅŸ olmalÄ±.
    # EÄŸer `get_data_dir()` geÃ§ersizse, tÃ¼m tahminler 0.5 dÃ¶ner â†’ bu kritik bir hata maskelenmesidir!
    # GeliÅŸtirme Ã¶nerisi: Model dosyalarÄ± var mÄ± diye kontrol edilmeli.
    smi = Chem.MolToSmiles(mol)
    featurizer = dc.feat.MolGraphConvFeaturizer()
    mol_feat = featurizer.featurize([smi])
    
    model_names = {
        "caco2": dc.models.GraphConvModel(1, model_dir=dc.utils.get_data_dir() + "/admet/caco2"),
        "pgp": dc.models.GraphConvModel(1, model_dir=dc.utils.get_data_dir() + "/admet/pgp"),
        "cyp3a4": dc.models.GraphConvModel(1, model_dir=dc.utils.get_data_dir() + "/admet/cyp3a4"),
        "herg": dc.models.GraphConvModel(1, model_dir=dc.utils.get_data_dir() + "/admet/herg"),
        "hepatotox": dc.models.GraphConvModel(1, model_dir=dc.utils.get_data_dir() + "/admet/hepatotox")
    }

    preds = {}
    for name, model in model_names.items():
        try:
            preds[name] = float(model.predict(mol_feat)[0][0])
        except Exception as e:
            print(f"âš ï¸ ADMET tahmini hatasÄ± ({name}): {e}")
            preds[name] = 0.5  # belirsizse nÃ¶tr skor

    # Normalize edilmiÅŸ genel skor (1 = ideal)
    absorption = preds["caco2"]
    distribution = 1 - preds["pgp"]
    metabolism = 1 - preds["cyp3a4"]
    toxicity = (1 - preds["herg"]) * (1 - preds["hepatotox"])

    admet_score = (0.3*absorption + 0.2*distribution + 0.2*metabolism + 0.3*toxicity)
    return max(0.0, min(1.0, admet_score))

# =====================
# 5. Docking (AutoDock Vina)
# =====================
def prepare_ligand_for_vina(mol, name_prefix):
    # ğŸ“Œ GELÄ°ÅTÄ°RÄ°CÄ° NOTU:
    # Open Babel baÄŸÄ±mlÄ±lÄ±ÄŸÄ± var â†’ sistemde kurulu olmalÄ±.
    # Alternatif: RDKit + AutoDockTools (ADT) scriptleri kullanÄ±labilir.
    pdbqt_file = os.path.join(OUT_DIR, f"{name_prefix}.pdbqt")
    mol_file = os.path.join(OUT_DIR, f"{name_prefix}.mol2")
    Chem.MolToMol2File(mol, mol_file)
    cmd = f"obabel {mol_file} -O {pdbqt_file} -xp"
    subprocess.run(cmd, shell=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
    return pdbqt_file

def dock_ligand(args):
    # ğŸ“Œ GELÄ°ÅTÄ°RÄ°CÄ° NOTU:
    # Vina komutu, pocket boyutunu standart sapmaya gÃ¶re belirler.
    # BazÄ± cepler iÃ§in bu Ã§ok kÃ¼Ã§Ã¼k/kalabalÄ±k olabilir â†’ dinamik boyut ayarÄ± Ã¶nerilir.
    i, ligand, pocket = args
    name_prefix = f"lig_{i}"
    pdbqt_file = prepare_ligand_for_vina(ligand['mol'], name_prefix)
    out_log = os.path.join(OUT_DIR, f"{name_prefix}_vina_out.txt")
    out_pdbqt = os.path.join(OUT_DIR, f"{name_prefix}_vina_out.pdbqt")

    x, y, z = pocket['center']
    size_x, size_y, size_z = pocket['size'] * 2

    cmd = (
        f"{VINA_PATH} --receptor {PDB_FILE} --ligand {pdbqt_file} "
        f"--center_x {x:.3f} --center_y {y:.3f} --center_z {z:.3f} "
        f"--size_x {size_x:.3f} --size_y {size_y:.3f} --size_z {size_z:.3f} "
        f"--out {out_pdbqt} --log {out_log}"
    )
    subprocess.run(cmd, shell=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)

    score = 999.0
    try:
        with open(out_log, "r") as f:
            for line in f:
                if line.strip().startswith("REMARK VINA RESULT:"):
                    try:
                        score = float(line.strip().split()[3])
                        break
                    except:
                        pass
    except FileNotFoundError:
        score = 999.0  # docking baÅŸarÄ±sÄ±zsa kÃ¶tÃ¼ skor ver
    return (i, score)

# =====================
# 6. Ana AkÄ±ÅŸ
# =====================
def main():
    print(" Pipeline baÅŸlatÄ±lÄ±yor...")
    pocket = analyze_pocket(PDB_FILE)

    ligands = generate_ligands_reinvent(NUM_LIGANDS)
    ligands = [l for l in ligands if lipinski_violations(l['mol']) <= 1]
    print(f" {len(ligands)} ligand Lipinski filtresinden geÃ§ti.")

    # --- ADMET hesaplama
    print("âš—ï¸ ADMET analizleri baÅŸlatÄ±lÄ±yor...")
    for l in ligands:
        l['qed'] = QED.qed(l['mol'])
        l['admet'] = calc_admet_score(l['mol'])

    # --- Docking
    print("âš™ï¸ Docking baÅŸlatÄ±lÄ±yor (paralel)...")
    with Pool(N_CPU) as pool:
        results = pool.map(dock_ligand, [(i, l, pocket) for i, l in enumerate(ligands)])
    for i, score in results:
        ligands[i]['dock_score'] = score

    # --- Skorlama
    # ğŸ“Œ GELÄ°ÅTÄ°RÄ°CÄ° NOTU:
    # Docking skoru negatif (dÃ¼ÅŸÃ¼k = iyi) olduÄŸu iÃ§in total skorda negatif katkÄ± verilmiÅŸtir.
    # Ancak normalizasyon (Ã¶rn. /20.0) keyfidir â†’ docking skoru daÄŸÄ±lÄ±mÄ±na gÃ¶re ayarlanmalÄ±.
    for l in ligands:
        l['total'] = (l['qed']*0.2 + l['admet']*0.4) - (l['dock_score']/20.0)

    top2 = sorted(ligands, key=lambda x: x['total'], reverse=True)[:2]

    # SDF kaydet
    sdf_file = os.path.join(OUT_DIR, "top2.sdf")
    writer = Chem.SDWriter(sdf_file)
    for l in top2:
        # ğŸ“Œ GELÄ°ÅTÄ°RÄ°CÄ° NOTU: SD etiketlerine skorlar eklenebilir!
        writer.write(l['mol'])
    writer.close()

    # PNG gÃ¶rÃ¼ntÃ¼leme
    img = Draw.MolsToGridImage(
        [l['mol'] for l in top2],
        molsPerRow=2,
        subImgSize=(400, 400),
        legends=[f"Dock={l['dock_score']:.2f}\nQED={l['qed']:.2f}\nADMET={l['admet']:.2f}" for l in top2]
    )
    img.save(os.path.join(OUT_DIR, "top2_ligands.png"))

    print(" En iyi 2 ligand:")
    for i, l in enumerate(top2, 1):
        print(f"{i}. {l['smiles']} | Dock={l['dock_score']:.2f} | QED={l['qed']:.2f} | ADMET={l['admet']:.2f}")
    print("ğŸ“ SonuÃ§ klasÃ¶rÃ¼:", OUT_DIR)

# =====================
if __name__ == "__main__":
    main()
